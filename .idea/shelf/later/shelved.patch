Index: crates/bsnext_system/src/tasks/notify_servers.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use actix::{Actor, Handler, ResponseFuture};\nuse bsnext_core::servers_supervisor::file_changed_handler::FilesChanged;\nuse bsnext_dto::internal::{InvocationId, TaskResult};\nuse bsnext_task::invocation::Invocation;\nuse bsnext_task::task_trigger::TaskTriggerSource;\n\n#[derive(Default)]\npub struct NotifyServers {}\n\nimpl NotifyServers {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\nimpl Actor for NotifyServers {\n    type Context = actix::Context<Self>;\n\n    fn started(&mut self, _ctx: &mut Self::Context) {\n        tracing::debug!(actor.lifecycle = \"started\", \"NotifyServers\");\n    }\n\n    fn stopped(&mut self, _ctx: &mut Self::Context) {\n        tracing::debug!(actor.lifecycle = \"stopped\", \"NotifyServers\");\n    }\n}\n\nimpl Handler<Invocation> for NotifyServers {\n    type Result = ResponseFuture<TaskResult>;\n\n    fn handle(\n        &mut self,\n        Invocation(_id, trigger): Invocation,\n        _ctx: &mut Self::Context,\n    ) -> Self::Result {\n        tracing::debug!(\"NotifyServers::TaskCommand\");\n        let comms = trigger.comms();\n        todo!(\"NotifyServers::TaskCommand\");\n        // let Some(sender) = comms.servers_recip.clone() else {\n        //     todo!(\"cannot get here?\")\n        // };\n        // match trigger.variant {\n        //     TaskTriggerSource::FsChanges {\n        //         changes,\n        //         fs_event_context,\n        //         ..\n        //     } => sender.do_send(FilesChanged {\n        //         paths: changes.clone(),\n        //         ctx: fs_event_context,\n        //     }),\n        //     TaskTriggerSource::Exec { .. } => {\n        //         todo!(\"I cannot accept this\")\n        //     }\n        // }\n        Box::pin(async { TaskResult::ok(InvocationId(0)) })\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crates/bsnext_system/src/tasks/notify_servers.rs b/crates/bsnext_system/src/tasks/notify_servers.rs
--- a/crates/bsnext_system/src/tasks/notify_servers.rs	(revision 665924548593233435ce285e66c86c01182fee75)
+++ b/crates/bsnext_system/src/tasks/notify_servers.rs	(date 1769977799108)
@@ -1,15 +1,17 @@
-use actix::{Actor, Handler, ResponseFuture};
+use actix::{Actor, Addr, Handler, Recipient, ResponseFuture};
+use bsnext_core::servers_supervisor::actor::ServersSupervisor;
 use bsnext_core::servers_supervisor::file_changed_handler::FilesChanged;
 use bsnext_dto::internal::{InvocationId, TaskResult};
 use bsnext_task::invocation::Invocation;
 use bsnext_task::task_trigger::TaskTriggerSource;
 
-#[derive(Default)]
-pub struct NotifyServers {}
+pub struct NotifyServers {
+    servers_addr: Recipient<FilesChanged>,
+}
 
 impl NotifyServers {
-    pub fn new() -> Self {
-        Self {}
+    pub fn new(servers_addr: Recipient<FilesChanged>) -> Self {
+        Self { servers_addr }
     }
 }
 
Index: crates/bsnext_system/src/tasks/bs_live_task.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use std::fmt::{Display, Formatter};\n\n#[derive(Debug, PartialEq, PartialOrd, Ord, Eq, Hash, Clone)]\npub enum BsLiveTask {\n    NotifyServer,\n    PublishExternalEvent,\n}\n\nimpl Display for BsLiveTask {\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n        match self {\n            BsLiveTask::NotifyServer => write!(f, \"BsLiveTask::NotifyServer\"),\n            BsLiveTask::PublishExternalEvent => write!(f, \"BsLiveTask::PublishExternalEvent\"),\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crates/bsnext_system/src/tasks/bs_live_task.rs b/crates/bsnext_system/src/tasks/bs_live_task.rs
--- a/crates/bsnext_system/src/tasks/bs_live_task.rs	(revision 665924548593233435ce285e66c86c01182fee75)
+++ b/crates/bsnext_system/src/tasks/bs_live_task.rs	(date 1769977859751)
@@ -1,15 +1,19 @@
+use actix::Recipient;
+use bsnext_core::servers_supervisor::file_changed_handler::FilesChanged;
 use std::fmt::{Display, Formatter};
 
-#[derive(Debug, PartialEq, PartialOrd, Ord, Eq, Hash, Clone)]
+#[derive(Debug, PartialEq, Eq, Hash, Clone)]
 pub enum BsLiveTask {
-    NotifyServer,
+    NotifyServer {
+        servers_addr: Recipient<FilesChanged>,
+    },
     PublishExternalEvent,
 }
 
 impl Display for BsLiveTask {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         match self {
-            BsLiveTask::NotifyServer => write!(f, "BsLiveTask::NotifyServer"),
+            BsLiveTask::NotifyServer { .. } => write!(f, "BsLiveTask::NotifyServer"),
             BsLiveTask::PublishExternalEvent => write!(f, "BsLiveTask::PublishExternalEvent"),
         }
     }
Index: crates/bsnext_system/src/handle_fs_event_grouping.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use crate::input_fs::from_input_path;\nuse crate::path_monitor::PathMonitorMeta;\nuse crate::path_watchable::PathWatchable;\nuse crate::tasks::bs_live_task::BsLiveTask;\nuse crate::tasks::task_list::TaskList;\nuse crate::tasks::Runnable;\nuse crate::trigger_fs_task::TriggerFsTaskEvent;\nuse crate::{BsSystem, OverrideInput};\nuse actix::AsyncContext;\nuse bsnext_core::servers_supervisor::file_changed_handler::FileChanged;\nuse bsnext_dto::external_events::ExternalEventsDTO;\nuse bsnext_dto::internal::{AnyEvent, InternalEvents};\nuse bsnext_dto::{StoppedWatchingDTO, WatchingDTO};\nuse bsnext_fs::{\n    BufferedChangeEvent, FsEvent, FsEventContext, FsEventGrouping, FsEventKind, PathAddedEvent,\n    PathDescriptionOwned, PathEvent,\n};\nuse bsnext_input::{Input, InputError, PathDefinition, PathDefs, PathError};\nuse bsnext_task::task_group::TaskGroup;\nuse bsnext_task::task_trigger::{TaskComms, TaskTrigger, TaskTriggerSource};\nuse tracing::{debug_span, info};\n\nimpl actix::Handler<FsEventGrouping> for BsSystem {\n    type Result = ();\n\n    fn handle(&mut self, msg: FsEventGrouping, ctx: &mut Self::Context) -> Self::Result {\n        let span = debug_span!(\"Handler->FsEventGrouping->BsSystem\");\n        let _guard = span.enter();\n        let next = match msg {\n            FsEventGrouping::Singular(fs_event) => self.handle_fs_event(fs_event),\n            FsEventGrouping::BufferedChange(buff) => {\n                if let Some((task_group, task_trigger, task_list)) = self.handle_buffered(buff) {\n                    tracing::debug!(\"will trigger task runner\");\n                    ctx.notify(TriggerFsTaskEvent::new(task_group, task_trigger, task_list));\n                }\n                None\n            }\n        };\n        if let Some(any_event) = next {\n            tracing::trace!(\"will publish any_event {:?}\", any_event);\n            self.publish_any_event(any_event)\n        }\n    }\n}\n\nimpl BsSystem {\n    fn handle_fs_event(&mut self, fs_event: FsEvent) -> Option<AnyEvent> {\n        match &fs_event.kind {\n            FsEventKind::Change(ch) if fs_event.fs_event_ctx.is_root() => {\n                tracing::info!(\"fs_event_ctx=root\");\n                match self.handle_input_change(ch) {\n                    // if the change included a new Input, use it\n                    (any_event, Some(input)) => {\n                        tracing::info!(\"will override input\");\n                        if let Some(addr) = &self.self_addr {\n                            addr.do_send(OverrideInput {\n                                input,\n                                original_event: any_event,\n                            });\n                        };\n                        // return None here so that the event is not published yet (the updated Input will do it)\n                        None\n                    }\n                    // otherwise publish the change as usual\n                    (evt, None) => Some(evt),\n                }\n            }\n            FsEventKind::Change(inner) => {\n                let evt = self.handle_any_change(&fs_event.fs_event_ctx, inner);\n                Some(evt)\n            }\n            FsEventKind::PathAdded(path) => {\n                let Some(pw) = self.monitor_meta(&fs_event.fs_event_ctx) else {\n                    tracing::error!(evt=?fs_event, \"missing monitor meta data\");\n                    return None;\n                };\n                self.handle_path_added(path, pw)\n            }\n            FsEventKind::PathRemoved(path) => self.handle_path_removed(path),\n            FsEventKind::PathNotFoundError(pdo) => self.handle_path_not_found(pdo),\n        }\n    }\n    fn monitor_meta(&self, incoming: &FsEventContext) -> Option<&PathMonitorMeta> {\n        if incoming.is_root() {\n            self.input_monitors.as_ref().map(|m| &m.monitor_meta)\n        } else {\n            self.any_monitors\n                .iter()\n                .find(|(.., (_addr, PathMonitorMeta { ref fs_ctx, .. }))| fs_ctx == incoming)\n                .map(|(.., (_addr, meta))| meta)\n        }\n    }\n    fn path_watchable(&self, incoming: &FsEventContext) -> Option<&PathWatchable> {\n        self.any_monitors\n            .iter()\n            .find(|(.., (_path_monitor, PathMonitorMeta { ref fs_ctx, .. }))| fs_ctx == incoming)\n            .map(|(pw, ..)| pw)\n    }\n    #[tracing::instrument(skip_all)]\n    fn handle_buffered(\n        &mut self,\n        buf: BufferedChangeEvent,\n    ) -> Option<(TaskGroup, TaskTrigger, TaskList)> {\n        tracing::debug!(msg.event_count = buf.events.len(), msg.ctx = ?buf.fs_ctx, ?buf);\n\n        let change = if let Some(mon) = &self.input_monitors {\n            if let Some(fp) = mon.input_ctx.file_path() {\n                tracing::debug!(\"Dropping input crossover {}\", fp.display());\n                buf.dropping_absolute(fp)\n            } else {\n                buf\n            }\n        } else {\n            buf\n        };\n\n        if change.events.is_empty() {\n            tracing::debug!(\n                \"Ignoring handle_buffered events because it was empty after removing input monitor\"\n            );\n            return None;\n        }\n\n        let paths = change\n            .events\n            .iter()\n            .map(|evt| evt.absolute.to_owned())\n            .collect::<Vec<_>>();\n\n        let fs_triggered_task_list = self.task_list_for_fs_event(&change.fs_ctx);\n\n        let variant = TaskTriggerSource::FsChanges {\n            changes: paths,\n            fs_event_context: change.fs_ctx,\n        };\n        let task_trigger = TaskTrigger {\n            variant,\n            comms: self.task_comms(),\n            invocation_id: 0,\n        };\n\n        // todo: use this example as a way to display a dry-run scenario\n        // let tree = fs_triggered_task_list.as_tree();\n        // let as_str = archy(&tree, None);\n        // println!(\"upcoming-->\");\n        // println!(\"{as_str}\");\n\n        Some((\n            TaskGroup::from(fs_triggered_task_list.clone()),\n            task_trigger,\n            fs_triggered_task_list,\n        ))\n    }\n\n    pub fn task_comms(&mut self) -> TaskComms {\n        let (Some(any_event_sender), Some(servers_addr)) =\n            (&self.any_event_sender, &self.servers_addr)\n        else {\n            todo!(\"must have these senders...?\");\n        };\n        TaskComms::new(any_event_sender.clone())\n    }\n\n    fn handle_any_change(\n        &mut self,\n        fs_event_ctx: &FsEventContext,\n        inner: &PathDescriptionOwned,\n    ) -> AnyEvent {\n        tracing::trace!(?inner, \"Other file changed\");\n        if let Some(servers) = &self.servers_addr {\n            servers.do_send(FileChanged {\n                path: inner.absolute.clone(),\n                ctx: *fs_event_ctx,\n            })\n        }\n        AnyEvent::External(ExternalEventsDTO::FileChanged(\n            bsnext_dto::FileChangedDTO::from_path_buf(\n                inner.relative.as_ref().unwrap_or(&inner.absolute),\n            ),\n        ))\n    }\n    fn handle_input_change(&mut self, inner: &PathDescriptionOwned) -> (AnyEvent, Option<Input>) {\n        tracing::info!(\"InputFile file changed {:?}\", inner);\n\n        let ctx = self\n            .input_monitors\n            .as_ref()\n            .map(|x| x.input_ctx.clone())\n            .unwrap_or_default();\n\n        let input = from_input_path(&inner.absolute, &ctx);\n\n        let Ok(input) = input else {\n            let err = input.unwrap_err();\n            return (AnyEvent::Internal(InternalEvents::InputError(*err)), None);\n        };\n\n        let Some(relative) = &inner.relative else {\n            todo!(\"todo: is this reachable?\")\n        };\n\n        (\n            AnyEvent::External(ExternalEventsDTO::InputFileChanged(\n                bsnext_dto::FileChangedDTO::from_path_buf(relative),\n            )),\n            Some(input),\n        )\n    }\n    fn handle_path_added(&self, path: &PathAddedEvent, meta: &PathMonitorMeta) -> Option<AnyEvent> {\n        Some(AnyEvent::External(ExternalEventsDTO::Watching(\n            WatchingDTO::from_path_buf(&path.path, meta.debounce),\n        )))\n    }\n\n    fn handle_path_removed(&mut self, path: &PathEvent) -> Option<AnyEvent> {\n        Some(AnyEvent::External(ExternalEventsDTO::WatchingStopped(\n            StoppedWatchingDTO::from_path_buf(&path.path),\n        )))\n    }\n\n    fn handle_path_not_found(&mut self, pdo: &PathEvent) -> Option<AnyEvent> {\n        let as_str = pdo.path.to_string_lossy().to_string();\n        let cwd = self.cwd.clone().unwrap();\n        let abs = cwd.join(&as_str);\n        let def = PathDefinition {\n            input: as_str,\n            cwd: self.cwd.clone().unwrap(),\n            absolute: abs,\n        };\n        let e = InputError::PathError(PathError::MissingPaths {\n            paths: PathDefs(vec![def]),\n        });\n        Some(AnyEvent::Internal(InternalEvents::InputError(e)))\n    }\n\n    #[tracing::instrument(skip_all)]\n    fn task_list_for_fs_event(&self, fs_event_ctx: &FsEventContext) -> TaskList {\n        let Some(path_watchable) = self.path_watchable(fs_event_ctx) else {\n            tracing::error!(\"did not find a matching monitor\");\n            return TaskList::seq(&[]);\n        };\n\n        info!(\"matching monitor, path_watchable: {}\", path_watchable);\n        info!(\"matching fs_event_ctx: {:?}\", fs_event_ctx);\n\n        let custom_task_list = path_watchable.task_list();\n        if custom_task_list.is_none() {\n            info!(\"no custom tasks given, NotifyServer + ExtEvent will be defaults\");\n        }\n        custom_task_list.map(ToOwned::to_owned).unwrap_or_else(|| {\n            TaskList::seq(&[\n                Runnable::BsLiveTask(BsLiveTask::NotifyServer),\n                Runnable::BsLiveTask(BsLiveTask::PublishExternalEvent),\n            ])\n        })\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crates/bsnext_system/src/handle_fs_event_grouping.rs b/crates/bsnext_system/src/handle_fs_event_grouping.rs
--- a/crates/bsnext_system/src/handle_fs_event_grouping.rs	(revision 665924548593233435ce285e66c86c01182fee75)
+++ b/crates/bsnext_system/src/handle_fs_event_grouping.rs	(date 1769977963967)
@@ -247,9 +247,16 @@
         if custom_task_list.is_none() {
             info!("no custom tasks given, NotifyServer + ExtEvent will be defaults");
         }
+
+        let Some(addr) = self.servers_addr else {
+            return TaskList::seq(&[Runnable::BsLiveTask(BsLiveTask::PublishExternalEvent)]);
+        };
+
         custom_task_list.map(ToOwned::to_owned).unwrap_or_else(|| {
             TaskList::seq(&[
-                Runnable::BsLiveTask(BsLiveTask::NotifyServer),
+                Runnable::BsLiveTask(BsLiveTask::NotifyServer {
+                    servers_addr: addr.recipient(),
+                }),
                 Runnable::BsLiveTask(BsLiveTask::PublishExternalEvent),
             ])
         })
Index: crates/bsnext_system/src/tasks/task_list.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use crate::tasks::bs_live_task::BsLiveTask;\nuse crate::tasks::sh_cmd::ShCmd;\nuse crate::tasks::{append, append_with_reports, Runnable};\nuse bsnext_dto::archy::ArchyNode;\nuse bsnext_dto::internal::TaskReport;\nuse bsnext_input::route::{BsLiveRunner, RunAll, RunOptItem, RunSeq};\nuse bsnext_task::task_entry::TaskEntry;\nuse bsnext_task::task_group::TaskGroup;\nuse bsnext_task::{OverlappingOpts, RunKind, SequenceOpts};\nuse std::collections::HashMap;\nuse std::hash::{DefaultHasher, Hash, Hasher};\n\n/// Represents a collection of tasks that can be run, categorized by their execution type (`RunKind`).\n///\n/// This `TaskList` struct provides a way to organize and manage a collection of runnable tasks.\n/// Each task is encapsulated within the `Runnable` type, and the execution behavior of the task list is determined\n/// by the `RunKind`.\n///\n/// # Fields\n///\n/// * `run_kind`:\n///   Specifies the type of execution behavior (defined by the [`RunKind`] enum) for the task list.\n///\n/// * `tasks`:\n///   A vector containing the individual tasks to be executed. Each task is represented as an instance of the `Runnable` struct.\n///\n#[derive(Debug, PartialEq, PartialOrd, Ord, Eq, Hash, Clone)]\npub struct TaskList {\n    pub run_kind: RunKind,\n    pub tasks: Vec<Runnable>,\n}\n\nimpl TreeDisplay for TaskList {\n    fn as_tree_label(&self, parent: u64) -> String {\n        let sqid = self.as_sqid(parent);\n        match &self.run_kind {\n            RunKind::Sequence { .. } => format!(\"[{sqid}] Seq: {} task(s)\", self.tasks.len()),\n            RunKind::Overlapping { opts } => format!(\n                \"[{sqid}] Overlapping {} task(s) (max concurrency: {})\",\n                self.tasks.len(),\n                opts.max_concurrent_items\n            ),\n        }\n    }\n}\n\nimpl TaskList {\n    pub fn all(p0: &[Runnable], opts: OverlappingOpts) -> Self {\n        Self {\n            run_kind: RunKind::Overlapping { opts },\n            tasks: p0.to_vec(),\n        }\n    }\n    pub fn seq(p0: &[Runnable]) -> Self {\n        Self {\n            run_kind: RunKind::Sequence {\n                opts: SequenceOpts::default(),\n            },\n            tasks: p0.to_vec(),\n        }\n    }\n    pub fn seq_opts(p0: &[Runnable], opts: SequenceOpts) -> Self {\n        Self {\n            run_kind: RunKind::Sequence { opts },\n            tasks: p0.to_vec(),\n        }\n    }\n    pub fn seq_from(p0: &[RunOptItem]) -> Self {\n        Self {\n            run_kind: RunKind::Sequence {\n                opts: SequenceOpts::default(),\n            },\n            tasks: p0.iter().map(Runnable::from).collect(),\n        }\n    }\n\n    pub fn add(&mut self, r: Runnable) {\n        self.tasks.push(r);\n    }\n\n    pub fn as_id(&self) -> u64 {\n        let mut hasher = DefaultHasher::new();\n        self.hash(&mut hasher);\n        hasher.finish()\n    }\n    pub fn as_id_with(&self, parent: u64) -> u64 {\n        let mut hasher = DefaultHasher::new();\n        self.hash(&mut hasher);\n        parent.hash(&mut hasher);\n        hasher.finish()\n    }\n}\n\nimpl TaskList {\n    pub fn as_sqid(&self, parent: u64) -> String {\n        let sqids = sqids::Sqids::default();\n        let sqid = sqids.encode(&[parent]).unwrap();\n        sqid.get(0..6).unwrap_or(&sqid).to_string()\n    }\n    pub fn as_tree(&self) -> ArchyNode {\n        let label = self.as_tree_label(0);\n        let mut first = ArchyNode::new(&label);\n        append(&mut first, &self.tasks);\n        first\n    }\n    pub fn as_tree_with_results(&self, hm: &HashMap<u64, TaskReport>) -> ArchyNode {\n        // let label = self.to_string();\n        let r = hm.get(&self.as_id());\n        let label = match r {\n            None => \"missing\".to_string(),\n            Some(_) => self.as_tree_label(0),\n        };\n        let mut first = ArchyNode::new(&label);\n        append_with_reports(&mut first, &self.tasks, hm);\n        first\n    }\n}\n\nimpl Runnable {\n    pub fn is_group(&self) -> bool {\n        match self {\n            Runnable::BsLiveTask(_) => false,\n            Runnable::Sh(_) => false,\n            Runnable::Many(_) => true,\n        }\n    }\n    pub fn as_id(&self) -> u64 {\n        let mut hasher = DefaultHasher::new();\n        self.hash(&mut hasher);\n        hasher.finish()\n    }\n    pub fn as_id_with(&self, parent: u64) -> u64 {\n        let mut hasher = DefaultHasher::new();\n        self.hash(&mut hasher);\n        parent.hash(&mut hasher);\n        hasher.finish()\n    }\n    pub fn as_sqid(&self, id: u64) -> String {\n        let sqids = sqids::Sqids::default();\n        let sqid = sqids.encode(&[id]).unwrap_or_else(|_| id.to_string());\n        sqid.get(0..6).map(String::from).unwrap_or(sqid)\n    }\n}\n\nimpl TreeDisplay for Runnable {\n    fn as_tree_label(&self, parent: u64) -> String {\n        let id = self.as_id_with(parent);\n        match self {\n            Runnable::BsLiveTask(item) => format!(\"{}{}\", \"Runnable::BsLiveTask\", item),\n            Runnable::Sh(sh) => format!(\"{} {}\", \"Runnable::Sh\", sh),\n            Runnable::Many(runner) => runner.as_tree_label(id),\n        }\n    }\n}\n\nimpl From<&RunOptItem> for Runnable {\n    fn from(value: &RunOptItem) -> Self {\n        match value {\n            RunOptItem::BsLive { bslive } => match bslive {\n                BsLiveRunner::NotifyServer => Self::BsLiveTask(BsLiveTask::NotifyServer),\n                BsLiveRunner::PublishExternalEvent => {\n                    Self::BsLiveTask(BsLiveTask::PublishExternalEvent)\n                }\n            },\n            RunOptItem::Sh(sh) => Self::Sh(ShCmd::from(sh)),\n            RunOptItem::ShImplicit(sh) => Self::Sh(ShCmd::new(sh.into())),\n            RunOptItem::All(RunAll { all, run_all_opts }) => {\n                let items: Vec<_> = all.iter().map(Runnable::from).collect();\n                let opts = OverlappingOpts {\n                    max_concurrent_items: run_all_opts.max,\n                    exit_on_failure: run_all_opts.exit_on_fail,\n                };\n                Self::Many(TaskList::all(&items, opts))\n            }\n            RunOptItem::Seq(RunSeq { seq, seq_opts }) => {\n                let items: Vec<_> = seq.iter().map(Runnable::from).collect();\n                let opts = SequenceOpts {\n                    exit_on_failure: seq_opts.exit_on_fail,\n                };\n                Self::Many(TaskList::seq_opts(&items, opts))\n            }\n        }\n    }\n}\n\nimpl From<RunOptItem> for Runnable {\n    fn from(value: RunOptItem) -> Self {\n        Runnable::from(&value)\n    }\n}\n\npub trait TreeDisplay {\n    fn as_tree_label(&self, parent: u64) -> String;\n}\n\nimpl From<TaskList> for TaskGroup {\n    fn from(runner: TaskList) -> Self {\n        let top_id = runner.as_id();\n        let boxed_tasks = runner\n            .tasks\n            .into_iter()\n            .enumerate()\n            .map(|(i, x)| -> TaskEntry {\n                let item_id = x.as_id_with(i as u64);\n                match x {\n                    Runnable::Many(runner) => {\n                        TaskEntry::new(Box::new(TaskGroup::from(runner)), item_id)\n                    }\n                    _ => TaskEntry::new(Box::new(x), item_id),\n                }\n            })\n            .collect::<Vec<TaskEntry>>();\n        match runner.run_kind {\n            RunKind::Sequence { opts } => Self::seq(boxed_tasks, opts, top_id),\n            RunKind::Overlapping { opts } => Self::all(boxed_tasks, opts, top_id),\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crates/bsnext_system/src/tasks/task_list.rs b/crates/bsnext_system/src/tasks/task_list.rs
--- a/crates/bsnext_system/src/tasks/task_list.rs	(revision 665924548593233435ce285e66c86c01182fee75)
+++ b/crates/bsnext_system/src/tasks/task_list.rs	(date 1769978264687)
@@ -153,11 +153,11 @@
     }
 }
 
-impl From<&RunOptItem> for Runnable {
-    fn from(value: &RunOptItem) -> Self {
+impl Runnable {
+    fn from_opt(value: &RunOptItem, servers_addr: ) -> Self {
         match value {
             RunOptItem::BsLive { bslive } => match bslive {
-                BsLiveRunner::NotifyServer => Self::BsLiveTask(BsLiveTask::NotifyServer),
+                BsLiveRunner::NotifyServer => Self::BsLiveTask(BsLiveTask::NotifyServer { servers_addr: }),
                 BsLiveRunner::PublishExternalEvent => {
                     Self::BsLiveTask(BsLiveTask::PublishExternalEvent)
                 }
Index: crates/bsnext_system/src/tasks/mod.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use crate::external_event_sender::ExternalEventSender;\nuse crate::tasks::notify_servers::NotifyServers;\nuse crate::tasks::sh_cmd::ShCmd;\nuse crate::tasks::task_list::{TaskList, TreeDisplay};\nuse actix::{Actor, Recipient};\nuse bs_live_task::BsLiveTask;\nuse bsnext_dto::archy::ArchyNode;\nuse bsnext_dto::internal::TaskReport;\nuse bsnext_task::as_actor::AsActor;\nuse bsnext_task::invocation::Invocation;\nuse std::collections::HashMap;\n\npub mod bs_live_task;\npub mod notify_servers;\npub mod sh_cmd;\npub mod task_list;\n\n#[derive(Debug, PartialEq, PartialOrd, Ord, Eq, Hash, Clone)]\npub enum Runnable {\n    BsLiveTask(BsLiveTask),\n    Sh(ShCmd),\n    Many(TaskList),\n}\n\nimpl AsActor for Runnable {\n    fn into_task_recipient(self: Box<Self>) -> Recipient<Invocation> {\n        match *self {\n            Runnable::BsLiveTask(BsLiveTask::NotifyServer) => {\n                let s = NotifyServers::new();\n                let s = s.start();\n                s.recipient()\n            }\n            Runnable::BsLiveTask(BsLiveTask::PublishExternalEvent) => {\n                let actor = ExternalEventSender::new();\n                let addr = actor.start();\n                addr.recipient()\n            }\n            Runnable::Sh(sh) => {\n                let s = sh.start();\n                s.recipient()\n            }\n            Runnable::Many(_) => unreachable!(\"The conversion to Task happens elsewhere\"),\n        }\n    }\n}\n\nfn append(archy: &mut ArchyNode, tasks: &[Runnable]) {\n    for (i, x) in tasks.iter().enumerate() {\n        let label = x.as_tree_label(i as u64);\n        match x {\n            Runnable::BsLiveTask(_) => archy.nodes.push(ArchyNode::new(&label)),\n            Runnable::Sh(_) => archy.nodes.push(ArchyNode::new(&label)),\n            Runnable::Many(runner) => {\n                let mut next = ArchyNode::new(&label);\n                append(&mut next, &runner.tasks);\n                archy.nodes.push(next);\n            }\n        }\n    }\n}\n\nfn append_with_reports(archy: &mut ArchyNode, tasks: &[Runnable], hm: &HashMap<u64, TaskReport>) {\n    for (i, runnable) in tasks.iter().enumerate() {\n        let id = runnable.as_id_with(i as u64);\n        let sqid = runnable.as_sqid(id);\n        let label = match hm.get(&id) {\n            None => format!(\"[{sqid}] − {}\", runnable.as_tree_label(i as u64)),\n            Some(report) => {\n                if runnable.is_group() {\n                    runnable.as_tree_label(i as u64)\n                } else {\n                    format!(\n                        \"[{sqid}] {} {}\",\n                        if report.is_ok() { \"✅\" } else { \"❌\" },\n                        runnable.as_tree_label(i as u64)\n                    )\n                }\n            }\n        };\n        match runnable {\n            Runnable::BsLiveTask(_) => archy.nodes.push(ArchyNode::new(&label)),\n            Runnable::Sh(_) => archy.nodes.push(ArchyNode::new(&label)),\n            Runnable::Many(runner) => {\n                let mut next = ArchyNode::new(&label);\n                append_with_reports(&mut next, &runner.tasks, hm);\n                archy.nodes.push(next);\n            }\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crates/bsnext_system/src/tasks/mod.rs b/crates/bsnext_system/src/tasks/mod.rs
--- a/crates/bsnext_system/src/tasks/mod.rs	(revision 665924548593233435ce285e66c86c01182fee75)
+++ b/crates/bsnext_system/src/tasks/mod.rs	(date 1769977694790)
@@ -25,8 +25,8 @@
 impl AsActor for Runnable {
     fn into_task_recipient(self: Box<Self>) -> Recipient<Invocation> {
         match *self {
-            Runnable::BsLiveTask(BsLiveTask::NotifyServer) => {
-                let s = NotifyServers::new();
+            Runnable::BsLiveTask(BsLiveTask::NotifyServer { servers_addr }) => {
+                let s = NotifyServers::new(servers_addr);
                 let s = s.start();
                 s.recipient()
             }
